#!/usr/bin/env bds
#vim: syntax=java

include "conf.bds"


help == general pipeline settings
out_dir 	:= "out"	help Output directory (default: out).
title		:= ""		help Prefix for HTML report and outputs without given prefix.

help == parallelization settings
no_par		:= false	help Serialize all tasks (individual tasks can still use multiple threads up to '-nth').
nth 		:= 8 		help Maximum # threads for a pipeline. (default: 8).

help == general resource settings
wt 		:= "5h50m"	help Walltime for all single-threaded tasks (example: 8:10:00, 3h, 3600, default: 5h50m, 5:50:00).
memory 		:= "7G"		help Maximum memory for all single-threaded tasks (equivalent to '-mem', example: 4.5G, 1024M, default: 7G).
unlimited_mem_wt:= false 	help Use unlimited max. memory and walltime.
use_system 	:= "" 		help Force to use a system (equivalent to 'bds -s [SYSTEM_NAME] ...', any system defined in bds.config can be used).
nice 		:= 0 		help Set process priority for all tasks (default: 0; -20 (highest) ~ 19 (lowest) ).
retrial		:= 0 		help # of Retrial for failed tasks (default: 0).
q 		:= ""		help Submit tasks to a specified cluster queue.

help == shell environment settings
mod 		:= ""		help Modules separated by ; (example: "bowtie/2.2.4; bwa/0.7.7; picard-tools/1.92").
shcmd 		:= ""		help Shell commands separated by ;. Shell var. must be written as ${VAR} not as $VAR (example: "export PATH=${PATH}:/usr/test; VAR=test"). 
addpath 	:= "" 		help Path separated by ; or : to be PREPENDED to \$PATH (example: "/bin/test:${HOME}/utils").
conda_env 	:= ""		help Anaconda Python environment name for all softwares including Python2.
conda_env_py3 	:= ""		help Anaconda Python environment name for Python3.


shcmd_init 	:= "" 	// Shell command executed prior to all BigDataScript tasks (use this for setting up shell environment)
shcmd_init_py3	:= "" 	// for softwares using python3
shcmd_finalize 	:= ""

string[] _tids_all 	// array of task ids currently running
int{} _nth_tasks 	// key: task id, value: # of threads for the task


init_general()
init_shell_env()


void init_general() { 

	out_dir 	= get_conf_val( out_dir, 		["out_dir"] )		
	no_par 		= get_conf_val_bool( no_par, 		["no_par"] )
	nth 		= get_conf_val_int( nth, 		["nth"] )
	wt 		= get_conf_val( wt, 			["wt"] )
	memory 		= get_conf_val( memory, 		["memory","mem"] )
	unlimited_mem_wt= get_conf_val_bool( unlimited_mem_wt, 	["unlimited_mem_wt"] )
	conda_env	= get_conf_val( conda_env, 		["conda_env"] )
	conda_env_py3	= get_conf_val( conda_env_py3, 		["conda_env_py3"] )
	use_system 	= get_conf_val( use_system, 		["use_system","system"] )
	nice 		= get_conf_val_int( nice, 		["nice"] )
	retrial 	= get_conf_val_int( retrial, 		["retrial","retry"] )
	q 		= get_conf_val( q, 			["q"] )

	if ( cmd_line_arg_has_key("mem") ) memory = get_cmd_line_arg_val( "mem" )
	if ( cmd_line_arg_has_key("system") ) use_system = get_cmd_line_arg_val( "system" )

	if ( nth > 32 ) error("Maximum # threads (-nth) for a pipeline should not exceed 32!")

	if ( nth <= 1 ) {
		print("\nWarning: Maximum # threads (-nth) for a pipeline is <= 1. Turning off parallelization... (-no_par)")
		nth = 1
		no_par = true
	}
	if ( nice <= -20 ) nice = -20
	if ( nice > 19 ) nice = 19
	if ( q == "" ) q = queue

	print_general()

	// cpus, mem and timeout are BDS variables for default resource settings
	if ( use_system != "" ) system 	= use_system
	if ( system.toLower() == "slurm" ) system = "generic"
	if ( q != "" ) queue = q

	cpus 		= -1 		// With cpus==-1, BDS does not pass number of threads to cluster engine (SGE, SLURM, ...), which means single-threaded
	mem 		= get_res_mem(memory,1)
	timeout 	= get_res_wt(wt)
	walltimeout 	= 3600*24*100 	// timeout var. in BigDataScript (100 days, jobs will never be stopped by BDS due to BDS timeout)
	retry 		= retrial

	if ( !is_cmd_line_arg_empty() ) out_dir = mkdir( out_dir ) // create output directory and get absolute path for it	
}

void print_general() {

	print("\n\n== general pipeline settings\n")
	print( "Output dir.\t\t\t: $out_dir\n" )
	print( "No parallel jobs\t\t: $no_par\n" )
	print( "Maximum # threads \t\t: $nth\n" )
	print( "Walltime (general)\t\t: $wt\n" )
	print( "Max. memory (general)\t\t: $memory\n" )
	print( "Env. for Anaconda python2\t: $conda_env\n" )
	print( "Env. for Anaconda python3\t: $conda_env_py3\n" )
	print( "Force to use a system\t\t: $use_system\n" )
	print( "Process priority (niceness)\t: $nice\n" )
	print( "Submit tasks to a cluster queue\t: $q\n" )

	if ( unlimited_mem_wt ) {
		print( "Use limited max. memory and walltime (jobs will be submitted to a cluster engine without memory and walltime settings)\n")
	}
}

void init_shell_env() {

	init_mods 	:= ["/etc/profile.d/modules.sh", "/etc/profile.d/modules.bash"] // environment modules (bash) initialization file paths (pick from the first if exists)
	init_mod 	:= "" // module init. shell script found

	// get shell var MODULESHOME if exists
	moduleshome := get_shell_var("MODULESHOME").replace("\n","")
	if (moduleshome!="") init_mods.add("$moduleshome/init/bash")

	string shellcmd, module, path, conda_py2, conda_py3

	// find env. modules init script
	for ( string file : init_mods ) {
		if ( file.exists() ) {
			init_mod = file
			break
		}
	}

	if ( init_mod == "" ) {
		print("\n\nInfo: Environments module not found on your system (e.g. /etc/profile.d/modules.sh). Ignoring shell env. parameters like '-mod'. \n")
	}

	// read from conf./env. file
	for( string k : conf.keys() ) {		
		string val = conf{k}	

		// concat. module
		if ( (k.indexOf("mod_")>=0) || (k=="mod") ) {

			if ( init_mod != "" ) {
				trimmed := val.trim().replace("module add ","").replace( ":", " " ).replace( ";", " " ).replace( ",", " " ).trim()
				trimmed = trimmed.replace( "   ", " ").replace( "  ", " ")
				module = module + " " + trimmed
			}
		}
		else if ( k.indexOf("shcmd")>=0 ) {

			shellcmd = shellcmd + " " + val + ";"
		}
		else if ( k.indexOf("addpath")>=0 ) {

			path = path + val.trim().replace(",",":").replace(";",":").replace(" ",":").replace(":::",":").replace("::",":") + ":"
		}
	}

	// read from cmd. line arg.
	if ( mod!="" ) {
		string module_header = ". $init_mod;"

		if ( init_mod != "" ) { // if /etc/profile.d/modules.sh exists

			trimmed := mod.trim().replace("module add ","").replace( ":", " " ).replace( ";", " " ).replace(","," " ).trim()
			trimmed = trimmed.replace( "   ", " ").replace( "  ", " ")
			module = module + " " + trimmed
		}
	}
	if ( shcmd!="" ) {
		shellcmd = shellcmd + shcmd.trim() + "; "
	}

	if ( addpath!="" ) {
		path = path + addpath.trim().replace(",",":").replace(";",":").replace(" ",":").replace(":::",":").replace("::",":") + ":"
	}

	if ( module !="" ) {
		module = ". $init_mod; module add " + module + ";"
	}

	// check script directories to add to PATH
	script_file_paths := get_script_file_paths()

	for ( string _path : script_file_paths ) {
		
		if ( _path.exists() ) {
			path = path + _path + ":"
		}
	}

	if ( path !="" ) {
		path = " export PATH=$path:\${PATH}:/bin:/usr/bin:/usr/local/bin:\${HOME}/.bds;"
	}

	// add conda env
	if ( conda_env != "" ) {
		conda_py2 = "if [[ -f $(which activate) ]]; then source activate $conda_env; fi; "
	}

	if ( conda_env_py3 != "" ) {
		conda_py3 = "if [[ -f $(which activate) ]]; then source activate $conda_env_py3; fi; "
	}

	// additional initialization
	shcmd_init_ := module + path + shellcmd
	shcmd_init_ += "; set -o pipefail" 		// to catch non-zero exit code in a UNIX pipe
	shcmd_init_ += "; STARTTIME=$(date +%s)" 	// to check running time for a task
	shcmd_init_ += "; renice -n $nice $$" 		// to set process priority (niceness)

	shcmd_init_ = shcmd_init_.replace( ": :", ":" ).replace( "::", ":" ).replace( "; ;", ";" ).replace( ";;", ";" )

	shcmd_init 	= conda_py2 + shcmd_init_
	shcmd_init_py3 	= conda_py3 + shcmd_init_

	if ( is_system_local() ) {
		shcmd_finalize = "TASKTIME=$[$(date +%s)-${STARTTIME}]; echo \"Task has finished (${TASKTIME} seconds).\""
	}
	else {
		shcmd_finalize = "TASKTIME=$[$(date +%s)-${STARTTIME}]; if [ ${TASKTIME} -lt 60 ]; then echo \"Waiting for $[60-${TASKTIME}] seconds.\"; sleep $[60-${TASKTIME}]; fi"
	}

	print( "\nShell command for initialization\t: $shcmd_init\n" )
	print( "\nShell command for initialization (py3)\t: $shcmd_init_py3\n" )
}

string get_rel_path( string path ) {

	rel_path := path.path().replace( out_dir.path(), "." )

	if ( rel_path == path.path() ) 	return ""
	else 				return rel_path
}

int get_res_wt( string str ) {

	return (unlimited_mem_wt || is_system_local() ) ? -1 : parse_time( str )
}

int get_res_mem( string str, int n ) {

	if ( n < 1 ) n = 1

	return (unlimited_mem_wt || is_system_local() ) ? -1 : parse_mem( str )/n
}

int get_res_mem( string str ) {

	return get_res_mem( str , 1 )
}

void wait_par( int nth_task ) {

	if ( nth_task < 1 ) nth_task = 1

	while ( true ) {
		sleep( rand()*1.0 + 0.5 )

		_tids_all_  := _tids_all // make dummy for thread safety

		string[] tids_running
		int nth_running 

		// get total # threads for currently running tasks, and find the oldest task
		for ( string tid : _tids_all_ ) {
			if ( !tid.isDone() ) {
				tids_running.add( tid )
				nth_running = nth_running + _nth_tasks{tid}
			}
		}

		if ( tids_running.size() == 0 ) {
			break
		}
		else if ( no_par || (nth_running+nth_task) > nth ) {
			//print("\nWait... ( $nth_running+$nth_task > $nth, nth_curr: $nth_running )\n")

			loop_cnt := 0
			while( true ) { // wait until one of running tasks finishes
				break_loop := false
				for ( string tid : tids_running ) {

					if ( tid.isDone() ) {
						break_loop = true
						break
					}
				}
				if ( break_loop ) break
				sleep( rand() + 0.5 )
			}
			sleep( rand()*1.0 + 0.5 )
		}
		else {
			break
		}
	}
}

void register_par( string tid, int nth_task ) {

	if ( nth_task < 1 ) nth_task = 1
	if ( tid == "" ) return

	//print("\nRegistering a task : $tid, $nth_task \n")
	_tids_all.add(tid)
	_nth_tasks{tid} = nth_task
}

int{} distribute_nth( int n, int{} weight ) { 
	// distribute_nth n according to weight
	// return: 0 is converted to 1

	int{} ret

	int sum 
	for ( int w : weight ) sum += w

	if ( sum == 0 ) error("distribute_nth: sum is zero. check if input file size is 0?\n")

	for ( string key : weight.keys() ) {
		w := weight{key}
		ret{key} = (n*w)/sum

		if ( ret{key} == 0 ) ret{key} = 1
	}

	while( true ) {

		int sum2
		for ( string key : weight.keys() ) sum2 += ret{key}

		if ( n > sum2 ) {

			string key_to_plus
			int max_diff = 0

			for ( string key : weight.keys() ) {
				diff := n*weight{key}-ret{key}*sum
				if ( diff > max_diff ) {
					key_to_plus = key
					max_diff = diff
				}
			}

			ret{key_to_plus}++
		}
		else {
			break
		}
	}

	print("Distributing $n threads to ... \n")
	print(ret)
	print("\n")

	return ret
}

int[] distribute_nth( int n, int[] weight ) { 
	// distribute_nth n according to weight
	// return: 0 is converted to 1

	int[] ret

	int sum 
	for ( int w : weight ) sum += w

	if ( sum == 0 ) error("distribute_nth: sum is zero. check if input file size is 0?\n")

	for ( int i=0; i<weight.size(); i++) {
		w := weight[i]
		to_add := (n*w)/sum
		if ( to_add == 0 ) to_add = 1
		ret.add( to_add )
	}

	while( true ) {

		int sum2
		for ( int i=0; i<weight.size(); i++) sum2 += ret[i]

		if ( n > sum2 ) {

			int id_to_plus
			int max_diff = 0

			for ( int i=0; i<weight.size(); i++) {
				diff := n*weight[i]-ret[i]*sum
				if ( diff > max_diff ) {
					id_to_plus = i
					max_diff = diff
				}
			}

			ret[id_to_plus]++
		}
		else {
			break
		}
	}

	print("Distributing $n threads to ... \n")
	print(ret)
	print("\n")

	return ret
}

string get_long_group_name( int ctl, int rep ) {

	return ( (ctl>0) ? "Control " : "Replicate ") + rep
}

string get_long_group_name( int rep ) {

	return "Replicate "+ rep
}

string get_group_name( int ctl, int rep ) {

	return ( (ctl>0) ? "ctl" : "rep") + rep
}

string get_group_name( int rep ) {

	return "rep" + rep
}

string get_long_name( int ctl, int rep ) {

	return ( (ctl>0) ? "Control " : "Replicate ") + rep
}

string get_long_name( int rep ) {

	return "Replicate " + rep
}
